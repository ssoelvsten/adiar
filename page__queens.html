<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adiar: Queens</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Adiar<span id="projectnumber">&#160;2.1.0</span>
   </div>
   <div id="projectbrief">An External Memory Decision Diagram Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('page__queens.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Queens</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md30">Queens</a><ul><li class="level2"><a href="#autotoc_md31">Variable Ordering</a></li>
<li class="level2"><a href="#autotoc_md32">Constructing the Board</a><ul><li class="level3"><a href="#autotoc_md33">S(i,j) : Single Position</a></li>
<li class="level3"><a href="#autotoc_md34">R(i) : Row</a></li>
<li class="level3"><a href="#autotoc_md35">B() : Board</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md36">Counting Solutions</a></li>
<li class="level2"><a href="#autotoc_md37">Enumerating all Solutions</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md30"></a>
Queens</h1>
<p>The queens problem is a classic problem that is easy to state and understand but fascinatingly hard to solve efficiently.</p>
<blockquote class="doxtable">
<p>&zwj;Given \(N\), in how many ways can \(N\) queens be placed on an \(N \times
N\) chess board without threatening each other? </p>
</blockquote>
<p>All code shown here can be found in <code>examples/queens.cpp</code>. You can also compile and run this file to play around with it yourself.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Variable Ordering</h2>
<p>Well stay with the simple row-by-row ordering of variables for now. That is, we represent whether a queen is placed at position \((i,j)\) on an \(N \times
N\) chess board as the truth value of the BDD variable \(x_{i,j} :=
x_{N\cdot i+j}\).</p>
<p>In C++, we can derive the label of each chess board position as follows.</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code hl_typedef" href="classadiar_1_1internal_1_1dd.html#a89544dd479c73f3704c989d54e72b10b">adiar::bdd::label_type</a> label_of_position(uint64_t i, uint64_t j)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (N * i) + j;</div>
<div class="line">}</div>
<div class="ttc" id="aclassadiar_1_1internal_1_1dd_html_a89544dd479c73f3704c989d54e72b10b"><div class="ttname"><a href="classadiar_1_1internal_1_1dd.html#a89544dd479c73f3704c989d54e72b10b">adiar::internal::dd::label_type</a></div><div class="ttdeci">node_type::label_type label_type</div><div class="ttdoc">Type of this node's variable label.</div><div class="ttdef"><b>Definition</b> dd.h:282</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Constructing the Board</h2>
<p>We construct the set of solutions for the Queens problem as described by Kunkle, Slavici, and Cooperman.</p>
<ul>
<li>[<a href="https://dl.acm.org/doi/abs/10.1145/1837210.1837222">Kunkle10</a>] Daniel Kunkle, Vlad Slavici, Gene Cooperman. ‚Äú*Parallel Disk-Based Computation for Large, Monolithic Binary Decision Diagrams*‚Äù. In: <em>PASCO '10: Proceedings of the 4th International Workshop on Parallel and Symbolic Computation</em>. 2010</li>
</ul>
<h3><a class="anchor" id="autotoc_md33"></a>
S(i,j) : Single Position</h3>
<p>Let us first restrict our attention to the base case of expressing the state of a single cell \((i,j)\). We need to express that a single queen is placed here and that it is in no conflict with any other queens on the board, i.e. there cannot be any queen on the same row, column or diagonal.</p>
<div class="fragment"><div class="line">  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</div>
<div class="line">8 ‚îÇ‚ï≤    ‚îÇ     ‚ï±     ‚îÇ</div>
<div class="line">7 ‚îÇ  ‚ï≤  ‚îÇ   ‚ï±       ‚îÇ</div>
<div class="line">6 ‚îÇ    ‚ï≤‚îÇ ‚ï±         ‚îÇ</div>
<div class="line">5 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄüëë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ</div>
<div class="line">4 ‚îÇ    ‚ï±‚îÇ  ‚ï≤        ‚îÇ</div>
<div class="line">3 ‚îÇ  ‚ï±  ‚îÇ    ‚ï≤      ‚îÇ</div>
<div class="line">2 ‚îÇ‚ï±    ‚îÇ      ‚ï≤    ‚îÇ</div>
<div class="line">1 ‚îÇ     ‚îÇ        ‚ï≤  ‚îÇ</div>
<div class="line">  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</div>
<div class="line">    a b c d e f g h</div>
</div><!-- fragment --><p>This essentially is the formula \(fx_{i,j} \wedge \neg
\mathit{is\_threatened}(i,j)\) where \(\mathit{is\_threatened}(i,j)\) is \(\top\) if one or more queens are placed on conflicting positions. We could construct this BDD using <code><a class="el" href="group__module____bdd.html#ga4967671bd4f3386c612bb0f13214543c" title="The BDD representing the i&#39;th variable.">adiar::bdd_ithvar</a></code>, <code><a class="el" href="group__module____bdd.html#ga7fae475d2fde0a55f486cefabd001ac3" title="Negation of a BDD.">adiar::bdd_not</a></code>, and <code><a class="el" href="group__module____bdd.html#gaee15c2a51e9b6e0cc62b7ce9e1b44d6e" title="The BDD representing the logical &#39;and&#39; of all the given variables, i.e. a term of variables.">adiar::bdd_and</a></code>. Yet, the resulting (reduced) BDD is very well structured. So, we can construct it explicitly! All BDDs are stored on disk bottom-up, so we'll have to start at the bottom-right corner and work ourselves back up to the top-left corner. We can skip all labels for cells that don't lie on the same row, column or the two diagonals. For the remaining cells, we have to check that all but the one for cell \((i,j)\) they are \(\bot\) while \((i,j)\) is \(\top\).</p>
<p>For example, for \(N = 3\) and \((i,j) = (1,0)\), i.e. for a queen placed at position 2A on a \(3\times 3\) chess board, the variable is \(x_3\) and no queen is allowed to be placed on the same row, \(x_4\) and \(x_5\), nor its column, \(x_0\) and \(6\), nor either column, \(x_1\) and \(x_7\). The resulting BDD looks like this.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="366" height="795"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>Since we construct it explicitly using the <code><a class="el" href="group__module____builder.html#gacd91e76ef56facef01409c952e0ec8ef" title="Builder for BDDs.">adiar::bdd_builder</a></code>, then the work we do in the base case goes down to only \(O(\text{scan}(N))\) time I/Os rather than \(O(\text{sort}(NÀÜ2))\). One pretty much cannot do this base case faster.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> queens_S(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classadiar_1_1builder.html">adiar::bdd_builder</a> builder;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> row = N - 1;</div>
<div class="line">  <a class="code hl_class" href="classadiar_1_1builder__ptr.html">adiar::bdd_ptr</a> next = builder.<a class="code hl_function" href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">add_node</a>(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="keywordtype">int</span> row_diff = std::max(row,i) - std::min(row,i);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (row_diff == 0) {</div>
<div class="line">      <span class="comment">// On row of the queen in question</span></div>
<div class="line">      <span class="keywordtype">int</span> column = N - 1;</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keyword">typename</span> <a class="code hl_typedef" href="classadiar_1_1internal_1_1dd.html#a89544dd479c73f3704c989d54e72b10b">adiar::bdd::label_type</a> label = label_of_position(row, column);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If (row, column) == (i,j), then the chain goes through high because</span></div>
<div class="line">        <span class="comment">// then we need to check the queen actually is placed here.</span></div>
<div class="line">        next = column == j</div>
<div class="line">          ? builder.<a class="code hl_function" href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">add_node</a>(label, <span class="keyword">false</span>, next)</div>
<div class="line">          : builder.<a class="code hl_function" href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">add_node</a>(label, next, <span class="keyword">false</span>);</div>
<div class="line">      } <span class="keywordflow">while</span> (column-- &gt; 0);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// On another row</span></div>
<div class="line">      <span class="keywordflow">if</span> (j + row_diff &lt; N) {</div>
<div class="line">        <span class="comment">// Diagonal to the right is within bounds</span></div>
<div class="line">        next = builder.<a class="code hl_function" href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">add_node</a>(label_of_position(row, j + row_diff), next, <span class="keyword">false</span>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Column</span></div>
<div class="line">      next = builder.<a class="code hl_function" href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">add_node</a>(label_of_position(row, j), next, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (row_diff &lt;= j) {</div>
<div class="line">        <span class="comment">// Diagonal to the left is within bounds</span></div>
<div class="line">        next = builder.<a class="code hl_function" href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">add_node</a>(label_of_position(row, j - row_diff), next, <span class="keyword">false</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">while</span> (row-- &gt; 0);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> res = builder.<a class="code hl_function" href="classadiar_1_1builder.html#ad352fdf568e8d100de19174386fc200c">build</a>();</div>
<div class="line"> </div>
<div class="line">  largest_nodes = std::max(largest_nodes, <a class="code hl_function" href="group__module____bdd.html#ga1117a062b67bed809d230f6fac83f60a">bdd_nodecount</a>(res));</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="ttc" id="aclassadiar_1_1bdd_html"><div class="ttname"><a href="classadiar_1_1bdd.html">adiar::bdd</a></div><div class="ttdoc">A reduced Binary Decision Diagram.</div><div class="ttdef"><b>Definition</b> bdd.h:53</div></div>
<div class="ttc" id="aclassadiar_1_1builder__ptr_html"><div class="ttname"><a href="classadiar_1_1builder__ptr.html">adiar::builder_ptr</a></div><div class="ttdoc">The pointer type that builders use to identify the nodes they have constructed in a decision diagram.</div><div class="ttdef"><b>Definition</b> builder.h:54</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html"><div class="ttname"><a href="classadiar_1_1builder.html">adiar::builder</a></div><div class="ttdoc">A builder for decision diagrams.</div><div class="ttdef"><b>Definition</b> builder.h:146</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html_a865e87726a9135ab4d2c8d17c2a8fe9a"><div class="ttname"><a href="classadiar_1_1builder.html#a865e87726a9135ab4d2c8d17c2a8fe9a">adiar::builder::add_node</a></div><div class="ttdeci">builder_ptr&lt; Policy &gt; add_node(typename Policy::label_type label, const builder_ptr&lt; Policy &gt; &amp;low, const builder_ptr&lt; Policy &gt; &amp;high)</div><div class="ttdoc">Add an internal node with a given label and its two children.</div><div class="ttdef"><b>Definition</b> builder.h:241</div></div>
<div class="ttc" id="aclassadiar_1_1builder_html_ad352fdf568e8d100de19174386fc200c"><div class="ttname"><a href="classadiar_1_1builder.html#ad352fdf568e8d100de19174386fc200c">adiar::builder::build</a></div><div class="ttdeci">Policy::dd_type build()</div><div class="ttdoc">Builds the decision diagram with the added nodes. This also clears the builder.</div><div class="ttdef"><b>Definition</b> builder.h:420</div></div>
<div class="ttc" id="agroup__module____bdd_html_ga1117a062b67bed809d230f6fac83f60a"><div class="ttname"><a href="group__module____bdd.html#ga1117a062b67bed809d230f6fac83f60a">adiar::bdd_nodecount</a></div><div class="ttdeci">size_t bdd_nodecount(const bdd &amp;f)</div><div class="ttdoc">The number of (internal) nodes used to represent the function.</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md34"></a>
R(i) : Row</h3>
<p>Now that we have a formula each cell, we can accumulate them with an \(\vee\). This ensures that there is at least one queen on each row since each <code>n_queens_S</code> is only \(\top\) if the queen is placed. Furthermore, the placed queen(s) are not in conflicts. Implicitly, this also provides an at-most-one constraints.</p>
<p>We could do so in two ways:</p>
<ul>
<li>Recursively split the row in half until we reach the base case of <code>n_queens_S</code>. This will minimise the number of Apply's that we will make.</li>
<li>Similar to a <code>list.fold</code> in functional programming languages, we iteratively combine them. This will minimise the number of BDDs that are "active" at any given time, since we only need to persist the input and output of each iteration.</li>
</ul>
<p>For Adiar to be able to achieve optimality on disk, it sacrifices the possibility of a hash-table to instantiate the entire forest of all currently active BDDs. In other words, each BDD is completely separate and no memory is saved if there is a major overlap. So, we will choose to do it iteratively.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> queens_R(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> out = queens_S(i, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; N; j++) {</div>
<div class="line">    out |= queens_S(i, j);</div>
<div class="line">    largest_nodes = std::max(largest_nodes, bdd_nodecount(out));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
B() : Board</h3>
<p>Now that we have each entire row done, we only need to combine them. Here we again iterate over all rows to combine them one-by-one. One can probably remove the code duplication that we now introduce.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> queens_B()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (N == 1) {</div>
<div class="line">    <span class="keywordflow">return</span> queens_S(0, 0);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> out = queens_R(0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; N; i++) {</div>
<div class="line">    out &amp;= queens_R(i);</div>
<div class="line">    largest_nodes = std::max(largest_nodes, bdd_nodecount(out));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Counting Solutions</h2>
<p>Above, we constructed a single BDD that os \(\top\) if and only if we have placed \(N\) queen on each row and without putting them in conflict with each other. That is, we have constructed the set of all valid solutions to the Queens problem. So, now we can merely count the number of satisfying assignments.</p>
<div class="fragment"><div class="line">uint64_t queens_count(<span class="keyword">const</span> <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> &amp;board)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="group__module____bdd.html#ga1f863a598b430b6c936900f855abb8c4">adiar::bdd_satcount</a>(board);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__module____bdd_html_ga1f863a598b430b6c936900f855abb8c4"><div class="ttname"><a href="group__module____bdd.html#ga1f863a598b430b6c936900f855abb8c4">adiar::bdd_satcount</a></div><div class="ttdeci">uint64_t bdd_satcount(const bdd &amp;f, bdd::label_type varcount)</div><div class="ttdoc">Count the number of assignments x that make f(x) true.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Enumerating all Solutions</h2>
<p>Based on this <a href="github.com/MartinFaartoft/n-queens-bdd/blob/master/report.tex">project report</a> by Thorbj√∏rn Nielsen and Martin Faartoft, we can use the BDD constructed above to guide a recursive procedure to enumerate all satisfying solutions. The BDD prunes the search tree when recursing.</p>
<p>Starting from the BDD created with <code>queens_B</code> above, we use <code><a class="el" href="group__module____bdd.html#gafbf9600fb919ec4d16144c8744ee276e" title="Restrict a single variable to a constant value.">adiar::bdd_restrict</a></code> to place queens one row at a time: starting from the left-most column in a row, we place the queen and then recurse. Recursion can stop early in two cases:</p>
<ul>
<li>If the given BDD already is trivially false. We have placed a queen, such that it conflicts with another.</li>
<li>If the number of unique paths in the restricted BDD is exactly one. Then we are forced to place the remaining queens.</li>
</ul>
<p>Since we want to back track in our choices, we may keep BDDs for each column. This is easily achieved by writing it as a recursive procedure. One should notice though, that this will result in multiple BDDs concurrently being instantiated in memory or on disk at the same time.</p>
<div class="fragment"><div class="line">uint64_t queens_list_rec(uint64_t N, uint64_t row,</div>
<div class="line">                         std::vector&lt;uint64_t&gt;&amp; partial_assignment,</div>
<div class="line">                         <span class="keyword">const</span> <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a>&amp; constraints)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="group__module____bdd.html#ga89c8736e3461536eb39cf4a323ab875b">adiar::bdd_isfalse</a>(constraints)) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">  deepest_row = std::max(deepest_row, row);</div>
<div class="line"> </div>
<div class="line">  uint64_t solutions = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (uint64_t col_q = 0; col_q &lt; N; col_q++) {</div>
<div class="line">    partial_assignment.push_back(col_q);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct the assignment for this entire row</span></div>
<div class="line">    std::vector&lt;adiar::pair&lt;adiar::bdd::label_type, bool&gt;&gt; column_assignment;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint64_t col = 0; col &lt; N; col++) {</div>
<div class="line">      column_assignment.push_back({label_of_position(row, col), col == col_q});</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a> restricted_constraints = <a class="code hl_function" href="group__module____bdd.html#gafbf9600fb919ec4d16144c8744ee276e">adiar::bdd_restrict</a>(constraints,</div>
<div class="line">                                                            column_assignment.begin(),</div>
<div class="line">                                                            column_assignment.end());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__module____bdd.html#gadd0becff66aaae9313c29248bc33750e">adiar::bdd_pathcount</a>(restricted_constraints) == 1) {</div>
<div class="line">      solutions += 1;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Obtain the lexicographically minimal true assignment. Well, only one</span></div>
<div class="line">      <span class="comment">// exists, so we get the only one left.</span></div>
<div class="line">      <a class="code hl_function" href="group__module____bdd.html#ga82d50901064486da23984c7dfac196c0">adiar::bdd_satmin</a>(restricted_constraints,</div>
<div class="line">                        [&amp;partial_assignment](<a class="code hl_typedef" href="namespaceadiar.html#a0bd43cb068187d7c464b6547ba6585d5">adiar::pair&lt;adiar::bdd::label_type, bool&gt;</a> xv) {</div>
<div class="line">                          <span class="comment">// Skip all empty cells, i.e. assignments to `false`.</span></div>
<div class="line">                          <span class="keywordflow">if</span> (!xv.second) { return; }</div>
<div class="line">                          <span class="comment">// Push non-empty cells, i.e. assignments to `true`. Since `bdd_satmin`</span></div>
<div class="line">                          <span class="comment">// provides the assignment (ascendingly) according to the variable</span></div>
<div class="line">                          <span class="comment">// ordering, then we can merely push to `partial_assignment`</span></div>
<div class="line">                          partial_assignment.push_back(xv.first);</div>
<div class="line">                        });</div>
<div class="line">      print_assignment(partial_assignment);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Forget the forced assignment again</span></div>
<div class="line">      <span class="keywordflow">for</span> (uint64_t r = N-1; r &gt; row; r--) {</div>
<div class="line">        partial_assignment.pop_back();</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="group__module____bdd.html#ga81eb97e73e588784178e8eaee96cdbc8">adiar::bdd_istrue</a>(restricted_constraints)) {</div>
<div class="line">      print_assignment(partial_assignment);</div>
<div class="line">      solutions += 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      solutions += queens_list_rec(N, row+1, partial_assignment, restricted_constraints);</div>
<div class="line">    }</div>
<div class="line">    partial_assignment.pop_back();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> solutions;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__module____bdd_html_ga81eb97e73e588784178e8eaee96cdbc8"><div class="ttname"><a href="group__module____bdd.html#ga81eb97e73e588784178e8eaee96cdbc8">adiar::bdd_istrue</a></div><div class="ttdeci">bool bdd_istrue(const bdd &amp;f)</div><div class="ttdoc">Whether a BDD is the constant true.</div></div>
<div class="ttc" id="agroup__module____bdd_html_ga82d50901064486da23984c7dfac196c0"><div class="ttname"><a href="group__module____bdd.html#ga82d50901064486da23984c7dfac196c0">adiar::bdd_satmin</a></div><div class="ttdeci">bdd bdd_satmin(const bdd &amp;f)</div><div class="ttdoc">The lexicographically smallest cube x such that f(x) is true.</div></div>
<div class="ttc" id="agroup__module____bdd_html_ga89c8736e3461536eb39cf4a323ab875b"><div class="ttname"><a href="group__module____bdd.html#ga89c8736e3461536eb39cf4a323ab875b">adiar::bdd_isfalse</a></div><div class="ttdeci">bool bdd_isfalse(const bdd &amp;f)</div><div class="ttdoc">Whether a BDD is the constant false.</div></div>
<div class="ttc" id="agroup__module____bdd_html_gadd0becff66aaae9313c29248bc33750e"><div class="ttname"><a href="group__module____bdd.html#gadd0becff66aaae9313c29248bc33750e">adiar::bdd_pathcount</a></div><div class="ttdeci">uint64_t bdd_pathcount(const bdd &amp;f)</div><div class="ttdoc">Count all unique (but not necessarily disjoint) paths to the true terminal.</div></div>
<div class="ttc" id="agroup__module____bdd_html_gafbf9600fb919ec4d16144c8744ee276e"><div class="ttname"><a href="group__module____bdd.html#gafbf9600fb919ec4d16144c8744ee276e">adiar::bdd_restrict</a></div><div class="ttdeci">__bdd bdd_restrict(const bdd &amp;f, bdd::label_type var, bool val)</div><div class="ttdoc">Restrict a single variable to a constant value.</div></div>
<div class="ttc" id="anamespaceadiar_html_a0bd43cb068187d7c464b6547ba6585d5"><div class="ttname"><a href="namespaceadiar.html#a0bd43cb068187d7c464b6547ba6585d5">adiar::pair</a></div><div class="ttdeci">std::pair&lt; T1, T2 &gt; pair</div><div class="ttdoc">A pair of values.</div><div class="ttdef"><b>Definition</b> types.h:53</div></div>
</div><!-- fragment --><p>The recursion can then be started with an empty assignment.</p>
<div class="fragment"><div class="line">uint64_t queens_list(uint64_t N, <span class="keyword">const</span> <a class="code hl_class" href="classadiar_1_1bdd.html">adiar::bdd</a>&amp; board)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;|  | solutions:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (N == 1) {</div>
<div class="line">    <span class="comment">// To make the recursive function work for N = 1 we would have to have the</span></div>
<div class="line">    <span class="comment">// adiar::count_paths check above at the beginning. That would in all other</span></div>
<div class="line">    <span class="comment">// cases merely result in an unecessary counting of paths at the very start.</span></div>
<div class="line">    std::vector&lt;uint64_t&gt; assignment { 0 };</div>
<div class="line">    print_assignment(assignment);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;uint64_t&gt; partial_assignment { };</div>
<div class="line">  partial_assignment.reserve(N);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> queens_list_rec(N, 0, partial_assignment, board);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This uses a helper function, <code>print_assignment</code> which converts the variable labels \(0, 1, \dots, N^2-1\) back to their coordinate and prints them in chess notation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_assignment(std::vector&lt;uint64_t&gt;&amp; assignment)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;|  |  | &quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">char</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> col = <span class="charliteral">&#39;A&#39;</span> + i;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> row = <span class="charliteral">&#39;1&#39;</span> + (assignment.at(i) % N);</div>
<div class="line">    std::cout &lt;&lt; row &lt;&lt; col &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="page__tutorial.html">Tutorial</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
